import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
import numpy as np
import os
from datetime import datetime, timedelta
from pandas.tseries.offsets import BDay
import  pickle
from mealpy import FloatVar, ARO
import tensorflow as tf
from tensorflow.keras.models import load_model

import plotly.express as px
from NODE import ODEfunc, NeuralODE 

from forecast_model import *
from process_data import *
from build_model import *
from evaluate_model import *

# ================================
# Streamlit UI
# ================================

# Sidebar
st.sidebar.title("Settings")

uploaded_file = st.sidebar.file_uploader("T·∫£i l√™n file d·ªØ li·ªáu c·ªï phi·∫øu", type=["csv"])

if uploaded_file is not None:
    # L·∫•y t√™n file, v√≠ d·ª•: FPT.csv ‚Üí ticker = "FPT"
    ticker = os.path.splitext(uploaded_file.name)[0].upper()  # Chuy·ªÉn v·ªÅ in hoa n·∫øu c·∫ßn

chart_type = st.sidebar.selectbox('Chart Type', ['Candlestick', 'Line'])

st.sidebar.markdown("### C·∫≠p nh·∫≠t d·ªØ li·ªáu")
update_data_btn = st.sidebar.button('Update')  # N√∫t ƒë·ªÉ c·∫≠p nh·∫≠t d·ªØ li·ªáu

st.sidebar.markdown("---")

# Tabs
st.title("Stock Prediction Dashboard")
tab1, tab2 = st.tabs(["üìä Preview Data", "üìà Prediction"])

with tab1:
    st.header("Data Preview")
    
    if update_data_btn:
        data = fetch_stock_data_from_file(uploaded_file)
        
        if data.empty:
            st.warning("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ho·∫∑c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá!")
            st.session_state.data = None
        else:
            data = add_technical_indicators(data)
            st.session_state.data = data  # l∆∞u v√†o session
    else:
        data = st.session_state.get('data', None)

    if data is not None and not data.empty:
        # V√≠ d·ª• hi·ªÉn th·ªã ch·ªâ s·ªë, bi·ªÉu ƒë·ªì gi·ªëng code c≈© nh∆∞ng b·ªè ticker
        last_close, change, pct_change, high, low, volume = calculate_metrics(data)
        st.metric(label="Last Price", value=f"{last_close:.2f} ", delta=f"{change:.2f} ({pct_change:.2f}%)")

        col1, col2, col3 = st.columns(3)
        col1.metric("High", f"{high:.2f}")
        col2.metric("Low", f"{low:.2f} ")
        col3.metric("Volume", f"{volume:,}")

        fig = go.Figure()
        if chart_type == 'Candlestick':
            fig.add_trace(go.Candlestick(x=data['Datetime'],
                                         open=data['open'],
                                         high=data['high'],
                                         low=data['low'],
                                         close=data['close']))
        else:
            fig = px.line(data, x='Datetime', y='close')

        # Th√™m indicator n·∫øu c√≥
        if 'SMA_20' in data.columns:
            fig.add_trace(go.Scatter(x=data['Datetime'], y=data['SMA_20'], name='SMA 20'))
        if 'EMA_20' in data.columns:
            fig.add_trace(go.Scatter(x=data['Datetime'], y=data['EMA_20'], name='EMA 20'))
        if 'MACD' in data.columns:
            fig.add_trace(go.Scatter(x=data['Datetime'], y=data['MACD'], name='MACD'))
        if 'RSI' in data.columns:
            fig.add_trace(go.Scatter(x=data['Datetime'], y=data['RSI'], name='RSI'))

        st.plotly_chart(fig, use_container_width=True)

        st.subheader('Historical Data')
        st.dataframe(data[['Datetime', 'open', 'high', 'low', 'close', 'volume']], use_container_width=True)

        st.subheader('Technical Indicators')
        st.dataframe(data[['Datetime', 'SMA_20', 'EMA_20', 'MACD', 'RSI']], use_container_width=True)
    else:
        st.info("Vui l√≤ng t·∫£i file d·ªØ li·ªáu v√† nh·∫•n 'Update' ƒë·ªÉ load d·ªØ li·ªáu.")

    # ƒê·∫£m b·∫£o session_state ƒë∆∞·ª£c kh·ªüi t·∫°o t·ª´ ƒë·∫ßu
    if 'data' not in st.session_state:
        st.session_state['data'] = None
    if 'predicted_values' not in st.session_state:
        st.session_state['predicted_values'] = None

    # --- Giao di·ªán ch·ªçn m√¥ h√¨nh v√† n√∫t Prediction ---
    st.header("üìà D·ª± ƒëoaÃÅn gi√° c·ªï phi·∫øu")
    st.markdown("### Ch·ªçn m√¥ h√¨nh")
    model = st.selectbox("Ch·ªçn m√¥ h√¨nh", ["NODE", "ARIMA-GRU", "LSTM", "LSTM-ARO", "GRU"])
    forecast_btn = st.button("Predict")

    # --- X·ª≠ l√Ω khi b·∫•m Forecast ---
    if forecast_btn:
        data = st.session_state.get('data', None)
        if data is None or data.empty:
            st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ d·ª± b√°o. Vui l√≤ng c·∫≠p nh·∫≠t d·ªØ li·ªáu tr∆∞·ªõc.")
            st.stop()

        data = data.copy()

        with st.spinner("üîÑ ƒêang x·ª≠ l√Ω d·ªØ li·ªáu..."):
            x_train, y_train, x_test, y_test, scaler, test_scaled, processed_data = process_data(data)
            train, test = process_data_arima(data)

        st.subheader("üîÆ K·∫øt qu·∫£ d·ª± ƒëoaÃÅn xu h∆∞·ªõng gi√° ƒë√≥ng c·ª≠a 10 ng√†y ti·∫øp theo")

        try:
            if model == 'NODE':
                model_path = f'../model/NODE-{ticker}.pth'
                node_model = load_node_model(model_path)
                st.session_state.predicted_values = forecast_node(node_model, scaler, test_scaled)

            elif model == 'ARIMA-GRU':
                gru_model = load_model(f'../model/GRU-{ticker}.h5', custom_objects={'mse': 'mean_squared_error'})
                with open(f'../model/ARIMA-{ticker}.pkl', 'rb') as f:
                    arima_model = pickle.load(f)

                predicted_values = forecast_arima_gru(
                    gru_model=gru_model,
                    arima_model=arima_model,
                    x_test=x_test,
                    y_test=y_test,
                    test_scaled=test_scaled,
                    scaler=scaler,
                    forecast_len=10
                )
            
            else:  # C√°c m√¥ h√¨nh Keras kh√°c
                keras_model_path = f'../model/{model}-{ticker}.h5'
                keras_model = load_model(keras_model_path, custom_objects={'mse': 'mean_squared_error'})
                st.session_state.predicted_values = forecast_keras(keras_model, scaler, test_scaled)

        except Exception as e:
            st.error(f"‚ùå L·ªói khi ch·∫°y m√¥ h√¨nh {model}: {e}")
            st.stop()

        # Hi·ªÉn th·ªã k·∫øt qu·∫£ d·ª± b√°o n·∫øu th√†nh c√¥ng
        if st.session_state.predicted_values is not None:
            forecast_dates = pd.date_range(start=data['Datetime'].iloc[-1] + timedelta(days=1), periods=10, freq=BDay())
            forecast_df = pd.DataFrame({
                'Date': forecast_dates,
                'Predict_Close': st.session_state.predicted_values.flatten()
            })

            fig = px.line(forecast_df,  y='Predict_Close', title="üìà D·ª± ƒëoaÃÅn gi√° ƒë√≥ng c·ª≠a")
            fig.update_traces(line=dict(color='red'))
            fig.update_layout(xaxis_title='Ng√†y', yaxis_title='Gi√° d·ª± ƒëoaÃÅn')
            st.plotly_chart(fig, use_container_width=True)

            next_day_price = forecast_df['Predict_Close'].iloc[0]
            st.metric("üìå Gi√° ng√†y ti·∫øp theo", f"{next_day_price:.2f}")

with tab2:
    st.header("üìà D·ª± ƒëoaÃÅn gi√° c·ªï phi·∫øu")

    if 'data' not in st.session_state or st.session_state.data is None:
        st.warning("Vui l√≤ng c·∫≠p nh·∫≠t d·ªØ li·ªáu ·ªü tab Preview Data tr∆∞·ªõc.")
        st.stop()

    data = st.session_state.data.copy()
    predicted = None
    model = st.selectbox("üîç Ch·ªçn m√¥ h√¨nh", ['NODE', 'ARIMA-GRU', 'LSTM-ARO'])
    
    # B∆∞·ªõc 1: Hi·ªÉn th·ªã c√°c tham s·ªë ph√π h·ª£p theo model ƒë√£ ch·ªçn
    if model == 'NODE':
        st.subheader("‚öôÔ∏è Tham s·ªë cho NODE")
        epochs_node = st.slider("Epochs", 10, 100, step=1)
        train_ratio = st.slider("üìä Training Rate", 0.5, 0.9, value=0.8, step=0.1)

    elif model == 'ARIMA-GRU':
        st.subheader("‚öôÔ∏è Tham s·ªë cho ARIMA-GRU")
        units = st.slider("Units", 64, 128, step=64)
        epochs = st.slider("Epochs", 10, 100, step=1, value=50)
        dropout = st.slider("Dropout", 0.0, 0.9, step=0.05, value=0.2)
        batch_size = st.slider("Batch Size", 32, 128, step=8, value=32)
        train_ratio = st.slider("üìä Training Rate", 0.5, 0.9, value=0.8, step=0.1)

    elif model == 'LSTM-ARO':
        st.subheader("‚öôÔ∏è Tham s·ªë hu·∫•n luy·ªán l·∫°i sau t·ªëi ∆∞u")
        train_epochs = st.slider("Epochs", 10, 100, step=1, value=50)
        batch_size = st.slider("Batch Size", 16, 128, step=8, value=32)
        train_ratio = st.slider("üìä Training Rate", 0.5, 0.9, value=0.8, step=0.1)

    # B∆∞·ªõc 2: N√∫t d·ª± ƒëoaÃÅn
    if st.button("üîÆ D·ª± ƒëoaÃÅn"):
        if model == 'NODE':
            x_train, y_train, x_test, y_test, scaler, test_scaled, _ = process_data(data, train_ratio)
            node_model = NeuralODE(ODEfunc(1))
            trained_model = train_NeuralODE(
                node_model, x_train, y_train, x_test, y_test,
                epochs=epochs_node, lr=0.01, patience=10
            )
            rmse, mae, predict_test_price, actual_test_price = evaluate_node(trained_model, x_test, y_test, scaler)
            predicted = forecast_node(trained_model, scaler, test_scaled)

        elif model == 'ARIMA-GRU':
            train, test = process_data_arima(data)
            x_train, y_train, x_test, y_test, scaler, test_scaled, _ = process_data(data)

            arima_model = build_arima_model(train)
            gru_model = build_gru_model(units=units, dropout=dropout)
            gru_model.fit(x_train, y_train, epochs=epochs, batch_size=batch_size, verbose=0)

            rmse, mae, predict_test_price, actual_test_price = evaluate_arimagru(gru_model,arima_model, x_test, y_test,test ,scaler)

            predicted = forecast_arima_gru(
                gru_model=gru_model,
                arima_model=arima_model,
                x_test=x_test,
                y_test=y_test,
                test_scaled=test_scaled,
                scaler=scaler,
                forecast_len=10
            )

        elif model == 'LSTM-ARO':
            x_train, y_train, x_test, y_test, scaler, test_scaled, data = process_data(data)

            with st.spinner("üîç ƒêang t·ªëi ∆∞u tham s·ªë b·∫±ng ARO..."):
                problem = {
                    "bounds": FloatVar(lb=[64, 64, 0.2, 10], ub=[256, 256, 0.7, 25], name="hyperparameters"),
                    "obj_func": objective_function,
                    "minmax": "min"
                }

                model_aro = ARO.OriginalARO(epoch=1, pop_size=5)
                gbest = model_aro.solve(problem)
                best_params = gbest.solution
                lstm_unit1, lstm_unit2 = map(int, best_params[:2])
                dropout_rate = round(best_params[2], 1)
                dense_unit = int(best_params[3])

            st.success(f"T·ªëi ∆∞u th√†nh c√¥ng: LSTM1={lstm_unit1}, LSTM2={lstm_unit2}, Dropout={dropout_rate}, Dense={dense_unit}")

            best_model = build_lstm_model(lstm_unit1, lstm_unit2, dropout_rate, dense_unit)
            early_stop = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
            best_model.fit(
                x_train, y_train,
                epochs=train_epochs, batch_size=batch_size,
                validation_data=(x_test, y_test),
                verbose=0, callbacks=[early_stop]
            )
            rmse, mae, predict_test_price, actual_test_price = evaluate_lstm(best_model, x_test, y_test, scaler)
            predicted = forecast_keras(best_model, scaler, test_scaled)

    if predicted is not None:
        forecast_dates = pd.date_range(start=data['Datetime'].iloc[-1] + timedelta(days=1), periods=10, freq=BDay())
        forecast_df = pd.DataFrame({
            'Date': forecast_dates,
            'Predict_Close': predicted.flatten()
        })

        compare_df = pd.DataFrame({
            'Actual Prices': actual_test_price.flatten(),
            'Predicted Prices': predict_test_price.flatten()
        }, index=range(len(y_test)))
        compare_df.index.name = "NgaÃÄy"
        compare_df_long = compare_df.reset_index().melt(id_vars='NgaÃÄy',value_vars=['Actual Prices', 'Predicted Prices'],
                                                         var_name='Price',value_name='GiaÃÅ d∆∞Ã£ baÃÅo')

        st.write(f"RMSE: {rmse:.4f}")
        st.write(f"MAE: {mae:.4f}")

        fig_compare = px.line(compare_df_long,x='NgaÃÄy', y='GiaÃÅ d∆∞Ã£ ƒëoaÃÅn', color='Price', title="üìà So saÃÅnh giaÃÅ th∆∞Ã£c t√™ÃÅ vaÃÄ giaÃÅ d∆∞Ã£ ƒëoaÃÅn", color_discrete_map={'Actual Prices': 'blue','Predicted Prices': 'orange'})
        fig.update_layout(xaxis_title='Ng√†y', yaxis_title='Gi√° d·ª± ƒëoaÃÅn')
        st.plotly_chart(fig_compare, use_container_width=True)

        st.markdown("---")

        fig = px.line(forecast_df, y='Predict_Close', title="üìà D·ª± ƒëoaÃÅn xu h∆∞·ªõng gi√° ƒë√≥ng c·ª≠a 10 ng√†y ti·∫øp theo")
        fig.update_traces(line=dict(color='red'))
        fig.update_layout(xaxis_title='Ng√†y', yaxis_title='Gi√° d·ª± ƒëoaÃÅn (VND)')

        st.plotly_chart(fig, use_container_width=True)

        next_day_price = forecast_df['Predict_Close'].iloc[0]
        st.metric("üìå Gi√° ng√†y ti·∫øp theo", f"{next_day_price:.2f} VND")


